<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>TimeSphere | Quests & Rewards</title>
<link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet" />
<link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600&display=swap" rel="stylesheet" />
<style>
  /* zachowujemy ten sam styl co w innych stronach */
  body {
    margin:0; font-family:'Poppins',sans-serif;
    background: linear-gradient(135deg,#5d54a4,#7c78b8);
    color:#fff; overflow-x:hidden;
  }
  header {
    display:flex; justify-content:space-between; align-items:center;
    padding:1rem 2rem;
    background: rgba(255,255,255,0.08);
    backdrop-filter: blur(8px);
    position:fixed; width:100%; top:0; z-index:10;
  }
  .menu-btn { font-size:2rem; cursor:pointer; transition: transform .3s; } 
  .menu-btn:hover { transform:scale(1.06); }
  .title { font-weight:600; font-size:1.4rem; }
  .right { display:flex; align-items:center; gap:1rem; }
  .clock, .logout-btn { font-weight:600; }
  .logout-btn { cursor:pointer; background: rgba(255,255,255,0.15); padding:0.5rem 1rem; border-radius:8px; transition: background .2s; }
  .logout-btn:hover { background: rgba(255,255,255,0.28); }

  /* side menu */
  #sideMenu {
    position:fixed; top:0; left:-260px;
    width:260px; height:100%;
    background: rgba(0,0,0,0.32);
    backdrop-filter: blur(8px);
    padding-top:4rem; transition:left .35s; z-index:20;
  }
  #sideMenu.open { left:0; }
  #sideMenu a { display:flex; align-items:center; gap:1rem; padding:1rem 1.25rem; color:white; text-decoration:none; transition: background .18s; }
  #sideMenu a:hover { background: rgba(255,255,255,0.06); }

  #menuOverlay { display:none; position:fixed; inset:0; background: rgba(0,0,0,0.32); z-index:15; }
  #menuOverlay.show { display:block; }

  main { margin-top:92px; padding:2rem; display:flex; gap:18px; justify-content:center; flex-wrap:wrap; }
  .panel { width:100%; max-width:1100px; background: rgba(255,255,255,0.06); border-radius:16px; padding:18px; box-shadow: 0 8px 30px rgba(0,0,0,0.25); }

  .row { display:flex; gap:12px; align-items:center; justify-content:space-between; flex-wrap:wrap; }
  h2 { margin:0; font-size:1.2rem; font-weight:700; }

  /* quests grid */
  .quests-grid { display:grid; grid-template-columns: repeat(auto-fill,minmax(260px,1fr)); gap:12px; margin-top:14px; }
  .quest-card {
    background: rgba(255,255,255,0.04);
    border-radius:12px;
    padding:14px;
    position:relative;
    overflow:hidden;
    min-height:120px;
    display:flex; flex-direction:column; gap:10px;
  }
  .quest-card .title { font-weight:700; font-size:1rem; display:flex; gap:8px; align-items:center;}
  .quest-card .meta { color: rgba(255,255,255,0.8); font-size:0.9rem; }
  .quest-progress { display:flex; justify-content:space-between; align-items:center; gap:8px; }
  .quest-actions { display:flex; gap:8px; margin-top:auto; }

  .btn { padding:8px 10px; border-radius:10px; background: rgba(255,255,255,0.12); border:none; color:#fff; cursor:pointer; font-weight:600; }
  .btn:hover { background: rgba(255,255,255,0.22); }

  /* locked overlay */
  .locked {
    position:absolute; inset:0; display:grid; place-items:center; background: rgba(0,0,0,0.45);
    backdrop-filter: blur(2px);
    text-align:center; padding:12px;
  }
  .locked .txt { font-weight:700; font-size:0.95rem; color:#ffd9a8; }
  .muted { color: rgba(255,255,255,0.85); }

  /* daily reward box */
  .daily-box { display:flex; gap:12px; align-items:center; flex-wrap:wrap; margin-top:12px; }
  .day-pill { background: rgba(255,255,255,0.05); padding:8px 12px; border-radius:10px; font-weight:700; }
  .day-pill.active { background: linear-gradient(90deg,#3ccf8e,#2fbf9a); color:#07120a; }

  /* claim button */
  .claim-btn { background: linear-gradient(90deg,#ffd24d,#ffb547); color:#311b00; padding:8px 12px; border-radius:10px; border:none; font-weight:800; cursor:pointer; }
  .claim-btn:disabled { opacity:0.5; cursor:not-allowed; }

  @media (max-width:920px){
    .quests-grid { grid-template-columns: 1fr 1fr; }
  }
  @media (max-width:640px){
    .quests-grid { grid-template-columns: 1fr; }
  }
</style>
</head>
<body>
  <header>
    <span class="menu-btn material-icons" id="menuToggle">menu</span>
    <div class="title">TimeSphere</div>
    <div class="right">
      <div class="clock" id="clock">--:--:--</div>
      <div class="logout-btn" id="logoutBtn">Logout</div>
    </div>
  </header>

  <nav id="sideMenu">
    <a href="/home/dashboard/"><span class="material-icons">home</span>Dashboard</a>
    <a href="/home/dashboard/users/"><span class="material-icons">group</span>Users</a>
    <a href="/home/dashboard/groups/"><span class="material-icons">groups</span>Groups</a>
    <a href="/home/dashboard/create/"><span class="material-icons">add_circle</span>Create</a>
    <a href="/home/dashboard/user-storage/"><span class="material-icons">storage</span>Storage</a>
    <a href="/home/dashboard/coins/"><span class="material-icons">paid</span>Coins</a>
    <a href="/home/dashboard/quests-and-rewards/" aria-current="page"><span class="material-icons">emoji_events</span>Quests</a>
    <a href="/home/dashboard/settings/"><span class="material-icons">settings</span>Settings</a>
  </nav>
  <div id="menuOverlay"></div>

  <main>
    <!-- Quests panel -->
    <section class="panel">
      <div class="row" style="justify-content:space-between;">
        <h2>Your Daily Quests</h2>
        <div class="muted" id="resetTimer">Reset in: --:--:--</div>
      </div>

      <div class="quests-grid" id="questsGrid">
        <!-- quest cards -->
      </div>
    </section>

    <!-- Rewards panel -->
    <section class="panel">
      <div class="row">
        <h2>Daily Reward</h2>
        <div class="muted" id="dailyInfo">Claim every 24h ‚Äî resets after inactivity</div>
      </div>

      <div class="daily-box" id="dailyBox" style="margin-top:12px;">
        <!-- day pills -->
      </div>

      <div style="margin-top:12px;">
        <button id="claimDailyBtn" class="claim-btn">Claim Daily Reward</button>
        <div class="muted" id="dailyStatus" style="margin-top:8px;">You haven't claimed yet.</div>
      </div>

    </section>
  </main>

<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/12.5.0/firebase-app.js";
import {
  getFirestore, doc, getDoc, setDoc, updateDoc, arrayUnion, arrayRemove,
  collection, getDocs, query, where, runTransaction, increment, onSnapshot
} from "https://www.gstatic.com/firebasejs/12.5.0/firebase-firestore.js";
import { getAuth, onAuthStateChanged, signOut } from "https://www.gstatic.com/firebasejs/12.5.0/firebase-auth.js";

/* ---------------- Firebase init (keep your config) ---------------- */
const firebaseConfig = {
  apiKey: "AIzaSyBiGzil9wA3CXZWxWjHsn7iKPkiYQozQW8",
  authDomain: "timesphere-9f7e0.firebaseapp.com",
  projectId: "timesphere-9f7e0",
  storageBucket: "timesphere-9f7e0.appspot.com",
  messagingSenderId: "94629610195",
  appId: "1:94629610195:web:a037e5c5aa0c5ba7e50a26"
};
const app = initializeApp(firebaseConfig);
const db = getFirestore(app);
const auth = getAuth(app);

/* ---------------- header clock, menu, logout (preserved) ---------------- */
function updateHeaderClock(){
  const now = new Date();
  try {
    const options = { hour12:false, hour:'2-digit', minute:'2-digit', second:'2-digit', timeZone:'Europe/London' };
    const el = document.getElementById('clock');
    if(el) el.textContent = new Intl.DateTimeFormat('en-GB', options).format(now);
  } catch(e){
    const el = document.getElementById('clock');
    if(el) el.textContent = now.toLocaleTimeString('en-GB', {hour12:false});
  }
}
setInterval(updateHeaderClock,1000);
updateHeaderClock();

const sideMenu = document.getElementById('sideMenu');
const overlay = document.getElementById('menuOverlay');
const menuToggleBtn = document.getElementById('menuToggle');
if(menuToggleBtn && sideMenu && overlay){
  menuToggleBtn.addEventListener('click', ()=>{ sideMenu.classList.add('open'); overlay.classList.add('show'); sideMenu.setAttribute('aria-hidden','false'); });
  overlay.addEventListener('click', ()=>{ sideMenu.classList.remove('open'); overlay.classList.remove('show'); sideMenu.setAttribute('aria-hidden','true'); });
}
const logoutBtn = document.getElementById('logoutBtn');
if(logoutBtn){
  logoutBtn.addEventListener('click', async () => { try{ await signOut(auth); }catch{} window.location.href='/login/index.html'; });
}

  function logDebug() {}

// --- Config & small helpers ---
const QUEST_IDS = [
  "Create clock","Create Countdown","Create Time","Create 3 Clocks",
  "Edit Clock","Edit Countdown","Share Countdown","Create Group","Account Length 10 Days"
];
const DAILY_SHOW = 5;
const DAILY_REWARDS = [25,45,80,130,250];
const DAILY_MAX_DAYS = 5;

function pad(n){ return String(n).padStart(2,'0'); }
function formatMsToHMS(ms){
  if(ms<=0) return "00:00:00";
  const s = Math.floor(ms/1000);
  const hh = Math.floor(s/3600);
  const mm = Math.floor((s%3600)/60);
  const ss = s%60;
  return `${pad(hh)}:${pad(mm)}:${pad(ss)}`;
}
function msUntilLondonMidnight(){
  try{
    const parts = new Intl.DateTimeFormat('en-GB', {
      timeZone: 'Europe/London', hour12:false,
      year:'numeric', month:'2-digit', day:'2-digit', hour:'2-digit', minute:'2-digit', second:'2-digit'
    }).formatToParts(new Date());
    const map = {};
    for(const p of parts) if(p.type !== 'literal') map[p.type] = p.value;
    const hour = Number(map.hour), minute = Number(map.minute), second = Number(map.second);
    const secondsPassed = hour*3600 + minute*60 + second;
    const secondsToMidnight = 24*3600 - secondsPassed;
    return secondsToMidnight * 1000;
  }catch(e){
    const now = new Date();
    const tomorrow = new Date(now.getFullYear(), now.getMonth(), now.getDate()+1);
    return tomorrow - now;
  }
}
function escapeHtml(s){ return String(s || '').replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m])); }
function safeId(s){ return encodeURIComponent(String(s)).replace(/[%]/g,'_'); }

// --- Quest generator (run once if missing) ---
// ustawiamy domy≈õlnie, kt√≥re questy majƒÖ byƒá publiczne (availableAll:true) a kt√≥re zablokowane (unlockCost)
async function ensureQuestsExist(){
  logDebug('üü° ensureQuestsExist() start');
  const questTemplates = [
    // TE 3 bƒôdƒÖ odblokowane dla wszystkich domy≈õlnie
    { id: "Create clock", title: "Create clock", total: 1, reward: 15, type: "daily", availableAll: true, unlockCost: null },
    { id: "Create Countdown", title: "Create Countdown", total: 1, reward: 15, type: "daily", availableAll: true, unlockCost: null },
    { id: "Create Time", title: "Create Time", total: 1, reward: 15, type: "daily", availableAll: true, unlockCost: null },

    // reszta sƒÖ zablokowane domy≈õlnie (availableAll:false) i majƒÖ cost do odblokowania
    { id: "Create 3 Clocks", title: "Create 3 Clocks", total: 3, reward: 40, type: "weekly", availableAll: false, unlockCost: 40 },
    { id: "Edit Clock", title: "Edit Clock", total: 1, reward: 20, type: "daily", availableAll: false, unlockCost: 15 },
    { id: "Edit Countdown", title: "Edit Countdown", total: 1, reward: 20, type: "daily", availableAll: false, unlockCost: 15 },
    { id: "Share Countdown", title: "Share Countdown", total: 1, reward: 30, type: "daily", availableAll: false, unlockCost: 30 },
    { id: "Create Group", title: "Create Group", total: 1, reward: 50, type: "daily", availableAll: false, unlockCost: 50 },
    { id: "Account Length 10 Days", title: "Account Length 10 Days", total: 10, reward: 160, type: "weekly", availableAll: false, unlockCost: 75 }
  ];

  for(const qt of questTemplates){
    try{
      const ref = doc(db,'quests', qt.id);
      const snap = await getDoc(ref);
      if(!snap.exists()){
        logDebug('Creating missing quest doc:', qt.id);
        await setDoc(ref, {
          id: qt.id,
          title: qt.title,
          total: qt.total,
          reward: qt.reward,
          unlockCost: qt.unlockCost !== undefined ? qt.unlockCost : null,
          availableUids: [],    // kto odblokowa≈Ç indywidualnie
          availableAll: qt.availableAll === true,
          type: qt.type || 'daily',
          createdAt: new Date().toISOString()
        });
        logDebug('‚úÖ Created quest:', qt.id);
      } else {
        // je≈õli dokument istnieje, upewnij siƒô, ≈ºe ma pola kt√≥rych oczekujemy (nie nadpisujemy wszystkiego)
        const data = snap.data() || {};
        const update = {};
        if(data.availableAll === undefined) update.availableAll = qt.availableAll === true;
        if(data.unlockCost === undefined && qt.unlockCost !== undefined) update.unlockCost = qt.unlockCost;
        if(Object.keys(update).length) {
          await updateDoc(ref, update);
          logDebug('Patched quest fields for', qt.id, update);
        } else {
          logDebug('‚úÖ Quest exists:', qt.id);
        }
      }
    } catch(err){
      console.error('ensureQuestsExist error', err);
      logDebug('‚ùå ensureQuestsExist error', (err && err.message) || err);
    }
  }
  logDebug('üü¢ ensureQuestsExist() done');
}

// --- Firestore helpers ---
async function ensureCoinsDoc(uid){
  const ref = doc(db,'user_coins', uid);
  const snap = await getDoc(ref);
  if(!snap.exists()){
    await setDoc(ref, { SphereCoins: 0 });
    return 0;
  }
  return Number(snap.data()?.SphereCoins || 0);
}

async function getUserQuestProgress(uid, questId){
  const ref = doc(db,'user_quests', `${uid}_${questId}`);
  const snap = await getDoc(ref);
  if(!snap.exists()) return { doneCount:0, total:0, claimed:false };
  return snap.data();
}

async function spendCoins(uid, amount){
  const ref = doc(db,'user_coins', uid);
  try{
    const res = await runTransaction(db, async (tx) => {
      const s = await tx.get(ref);
      let cur = 0;
      if(!s.exists()){
        cur = 0;
        tx.set(ref, { SphereCoins: 0 });
      } else {
        cur = Number(s.data().SphereCoins || 0);
      }
      if(cur < amount) return { ok:false, cur };
      tx.update(ref, { SphereCoins: Number((cur - amount).toFixed(0)) });
      return { ok:true, cur };
    });
    return res.ok === true;
  } catch(e){
    console.error('spendCoins error', e);
    logDebug('spendCoins error', (e && e.message) || e);
    return false;
  }
}

// Claim quest reward: read-then-write in transaction (Firestore requirement)
async function claimQuestReward(uid, questId, reward){
  const uqRef = doc(db,'user_quests', `${uid}_${questId}`);
  const coinsRef = doc(db,'user_coins', uid);
  try{
    await runTransaction(db, async (tx) => {
      const uqSnap = await tx.get(uqRef);
      const coinsSnap = await tx.get(coinsRef);

      if(uqSnap.exists()){
        const data = uqSnap.data();
        if(data.claimed) throw new Error('Already claimed');
      }

      if(!uqSnap.exists()){
        tx.set(uqRef, { uid, questId, doneCount: 0, total: 0, claimed: true, claimedAt: new Date() });
      } else {
        tx.update(uqRef, { claimed: true, claimedAt: new Date() });
      }

      if(!coinsSnap.exists()){
        tx.set(coinsRef, { SphereCoins: reward });
      } else {
        const cur = Number(coinsSnap.data().SphereCoins || 0);
        tx.update(coinsRef, { SphereCoins: Number((cur + reward).toFixed(0)) });
      }
    });
    logDebug('‚úÖ claimQuestReward success', uid, questId, reward);
    return true;
  } catch(err){
    console.error('claimQuestReward error', err);
    logDebug('‚ùå claimQuestReward error', (err && err.message) || err);
    throw err;
  }
}

async function unlockQuestForUser(uid, questId, cost){
  // najpierw spr√≥buj pobraƒá monety i zap≈Çaciƒá (spendCoins robi to w transakcji)
  const ok = await spendCoins(uid, cost);
  if(!ok) throw new Error('Insufficient coins');
  // dodaj UID do availableUids (trwa≈Çe odblokowanie)
  await updateDoc(doc(db,'quests', questId), { availableUids: arrayUnion(uid) });
}

/* ----------------- Main UI: load & render quests ----------------- */
async function loadAndRenderQuests(uid){
  logDebug('üü° loadAndRenderQuests start for', uid);
  const questsGrid = document.getElementById('questsGrid');
  if(!questsGrid){
    logDebug('‚ùå questsGrid not found in DOM');
    return;
  }
  questsGrid.innerHTML = "<div class='muted'>Loading quests‚Ä¶</div>";
  try{
    const qSnap = await getDocs(collection(db,'quests'));
    logDebug('üì¶ fetched quests count:', qSnap.size);
    if(qSnap.empty){
      questsGrid.innerHTML = "<div class='muted'>No quests available.</div>";
      return;
    }

    // przygotuj tablice unlocked / locked dla wyboru widocznych piƒôciu
    const all = qSnap.docs.map(d => ({ id: d.id, ...(d.data()||{}) }));
    const unlocked = [];
    const locked = [];
    for(const q of all){
      const availableAll = !!q.availableAll;
      const availableUids = Array.isArray(q.availableUids) ? q.availableUids : [];
      const isUnlocked = availableAll || availableUids.includes(uid);
      if(isUnlocked) unlocked.push(q); else locked.push(q);
    }

    // chcemy pokazaƒá dok≈Çadnie 5: 3 odblokowane i 2 zablokowane (je≈õli dostƒôpne)
    const chosen = [];
    // 1) wybierz do 3 odblokowanych (losowo je≈õli wiƒôcej)
    if(unlocked.length <= 3){
      chosen.push(...unlocked);
    } else {
      // losuj 3
      for(let i=0;i<3;i++){
        const idx = Math.floor(Math.random() * unlocked.length);
        chosen.push(unlocked.splice(idx,1)[0]);
      }
    }
    // 2) wybierz do 2 zablokowanych (je≈õli brak, dope≈Çnij z nieu≈ºytych odblokowanych)
    if(locked.length >= 2){
      // losuj 2 z locked
      for(let i=0;i<2;i++){
        const idx = Math.floor(Math.random() * locked.length);
        chosen.push(locked.splice(idx,1)[0]);
      }
    } else {
      // je≈õli brak zablokowanych, dope≈Çnij z unlocked (je≈õli sƒÖ dodatkowe)
      const need = 5 - chosen.length;
      while(need > chosen.length && unlocked.length){
        chosen.push(unlocked.pop());
      }
      // je≈õli dalej kr√≥cej ‚Äî u≈ºyj pozosta≈Çych locked (nawet je≈õli mniej ni≈º 2)
      while(chosen.length < 5 && locked.length){
        chosen.push(locked.pop());
      }
    }

    // je≈ºeli nadal mniej ni≈º 5, dope≈Çnij dowolnymi z all
    let iAll = 0;
    while(chosen.length < Math.min(5, all.length) && iAll < all.length){
      if(!chosen.includes(all[iAll])) chosen.push(all[iAll]);
      iAll++;
    }

    // render
    questsGrid.innerHTML = '';
    for(const q of chosen){
      const qid = q.id;
      const title = q.title || q.name || qid;
      const total = Number(q.total || 1);
      const reward = Number(q.reward || 0);
      const unlockCost = (q.unlockCost !== undefined ? Number(q.unlockCost) : null);
      const availableUids = Array.isArray(q.availableUids) ? q.availableUids : [];
      const availableAll = !!q.availableAll;
      const isAvailable = availableAll || availableUids.includes(uid);

      const progress = await getUserQuestProgress(uid, qid);
      const done = Number(progress.doneCount || 0);
      const claimed = Boolean(progress.claimed);

      const card = document.createElement('div');
      card.className = 'quest-card';
      card.style.padding = '12px';
      card.style.marginBottom = '10px';
      card.style.background = 'rgba(255,255,255,0.03)';
      card.style.borderRadius = '10px';

      // locked visual: pokaz k≈Ç√≥dkƒô i informacjƒô Unlock for: X
      if(!isAvailable){
        card.innerHTML = `
          <div style="display:flex;gap:10px;align-items:center;">
            <span class="material-icons">lock</span>
            <div style="flex:1">
              <div style="font-weight:700">${escapeHtml(title)}</div>
              <div class="muted">Locked ‚Äî Unlock for: <strong>${unlockCost !== null ? unlockCost : '?'}</strong> coins</div>
              <div class="muted">Progress: <strong>${done}</strong> / ${total}</div>
            </div>
          </div>
          <div style="margin-top:8px"><button class="btn" id="unlock-btn-${safeId(qid)}">Unlock (${unlockCost !== null ? unlockCost : '?'})</button></div>
        `;
      } else {
        // dostƒôpny ‚Äî pokaz progress i ewentualny claim
        card.innerHTML = `
          <div style="display:flex;gap:10px;align-items:center;">
            <span class="material-icons">task</span>
            <div style="flex:1">
              <div style="font-weight:700">${escapeHtml(title)}</div>
              <div class="muted">Progress: <strong>${done}</strong> / ${total} ‚Äî Reward: <strong>${reward}</strong> coins</div>
            </div>
          </div>
          <div style="margin-top:8px;display:flex;justify-content:space-between;align-items:center">
            <div class="muted" id="quest-${safeId(qid)}-uptime">Update quest in: --:--:--</div>
            <div class="quest-actions"></div>
          </div>
        `;
      }

      questsGrid.appendChild(card);

      // attach handlers
      if(!isAvailable){
        const btn = document.getElementById(`unlock-btn-${safeId(qid)}`);
        if(btn){
          btn.addEventListener('click', async () => {
            btn.disabled = true;
            btn.textContent = 'Processing‚Ä¶';
            try{
              if(unlockCost === null){ alert('This quest cannot be unlocked'); btn.disabled=false; btn.textContent=`Unlock (${unlockCost})`; return; }
              const ok = await spendCoins(uid, unlockCost);
              if(!ok){ alert('Not enough coins to unlock'); btn.disabled=false; btn.textContent=`Unlock (${unlockCost})`; return; }
              await updateDoc(doc(db,'quests', qid), { availableUids: arrayUnion(uid) });
              alert('Quest unlocked!');
              await loadAndRenderQuests(uid);
            } catch(err){
              console.error('unlock error', err);
              alert('Unlock failed: ' + (err.message || err));
              btn.disabled = false;
              btn.textContent = `Unlock (${unlockCost})`;
            }
          });
        }
      } else {
        // claim logic or status
        const actions = card.querySelector('.quest-actions');
        if(done >= total && !claimed){
          const claimBtn = document.createElement('button');
          claimBtn.className = 'claim-btn';
          claimBtn.textContent = 'Claim coins';
          claimBtn.addEventListener('click', async ()=>{
            try{
              await claimQuestReward(uid, qid, reward);
              alert(`Claimed ${reward} coins!`);
              await loadAndRenderQuests(uid);
            } catch(err){
              console.error('claim error', err);
              alert('Claim failed: ' + (err.message || err));
            }
          });
          actions.appendChild(claimBtn);
        } else {
          const rem = Math.max(0, total - done);
          const info = document.createElement('div');
          info.className = 'muted';
          info.textContent = (rem === 0 ? (claimed ? 'Completed' : 'Ready') : `Need ${rem}`);
          actions.appendChild(info);
        }
        // uptime timer
        const uptimeEl = card.querySelector(`#quest-${safeId(qid)}-uptime`);
        if(uptimeEl){
          const updateUptime = () => { uptimeEl.textContent = 'Update quest in: ' + formatMsToHMS(msUntilLondonMidnight()); };
          updateUptime();
          setInterval(updateUptime, 1000);
        }
      }
    }

    logDebug('üü¢ loadAndRenderQuests done, rendered:', Math.min(5, all.length));
  } catch(err){
    console.error('loadAndRenderQuests error', err);
    logDebug('‚ùå loadAndRenderQuests error', (err && err.message) || err);
    if(questsGrid) questsGrid.innerHTML = "<div class='muted'>Error loading quests.</div>";
  }
}
  
/* ---------------- Daily reward UI ---------------- */
async function loadDailyUI(uid){
  try{
    const drRef = doc(db,'daily_rewards', uid);
    const drSnap = await getDoc(drRef);
    const dailyBox = document.getElementById('dailyBox');
    const dailyStatus = document.getElementById('dailyStatus');
    const claimDailyBtn = document.getElementById('claimDailyBtn');
    if(!dailyBox || !dailyStatus || !claimDailyBtn) {
      logDebug('Daily UI elements not found, skipping daily UI');
      return;
    }

    let day = 0;
    let lastClaim = null;
    if(drSnap.exists()){
      const d = drSnap.data();
      day = Number(d.dayNumber || 0);
      lastClaim = d.lastClaimed ? (d.lastClaimed.toDate ? d.lastClaimed.toDate() : new Date(d.lastClaimed)) : null;
    }

    dailyBox.innerHTML = '';
    for(let i=1;i<=DAILY_MAX_DAYS;i++){
      const pill = document.createElement('div');
      pill.textContent = `Day #${i}: ${DAILY_REWARDS[i-1] || DAILY_REWARDS[DAILY_REWARDS.length-1]} coins`;
      pill.style.padding = '6px';
      pill.style.borderRadius = '8px';
      pill.style.margin = '4px';
      pill.style.display = 'inline-block';
      if(i===day) pill.style.outline = '2px solid rgba(255,255,255,0.12)';
      dailyBox.appendChild(pill);
    }

    dailyStatus.textContent = lastClaim ? ('Last claimed: ' + lastClaim.toLocaleString()) : 'You have not claimed any daily reward yet.';
    claimDailyBtn.disabled = false;
    claimDailyBtn.textContent = 'Claim Daily Reward';

    claimDailyBtn.onclick = async () => {
      try{
        const snap = await getDoc(drRef);
        let curDay = 0;
        let last = null;
        if(snap.exists()){
          curDay = Number(snap.data().dayNumber || 0);
          last = snap.data().lastClaimed ? (snap.data().lastClaimed.toDate ? snap.data().lastClaimed.toDate() : new Date(snap.data().lastClaimed)) : null;
        }
        const now = new Date();
        if(last){
          const diff = now - last;
          if(diff < 24*3600*1000){
            const remain = formatMsToHMS(24*3600*1000 - diff);
            return alert('You can claim next daily reward in: ' + remain);
          }
        }

        let nextDay = 1;
        if(last && (now - last) <= (48*3600*1000)){
          nextDay = Math.min(DAILY_MAX_DAYS, (curDay || 0) + 1);
        } else {
          nextDay = 1;
        }
        const coinsToGive = DAILY_REWARDS[nextDay-1] || DAILY_REWARDS[DAILY_REWARDS.length-1];

        await runTransaction(db, async (tx) => {
          const drS = await tx.get(drRef);
          const coinsRef = doc(db,'user_coins', uid);
          const cs = await tx.get(coinsRef);

          if(!drS.exists()){
            tx.set(drRef, { dayNumber: nextDay, lastClaimed: new Date() });
          } else {
            tx.update(drRef, { dayNumber: nextDay, lastClaimed: new Date() });
          }

          if(!cs.exists()){
            tx.set(coinsRef, { SphereCoins: coinsToGive });
          } else {
            const cur = Number(cs.data().SphereCoins || 0);
            tx.update(coinsRef, { SphereCoins: Number((cur + coinsToGive).toFixed(0)) });
          }
        });

        alert(`You received ${coinsToGive} coins for Day #${nextDay}!`);
        await loadDailyUI(uid);
      } catch(err){
        console.error('claimDaily error', err);
        logDebug('‚ùå claimDaily error', (err && err.message) || err);
        alert('Could not claim daily reward: ' + (err.message || err));
      }
    };

    if(lastClaim && (new Date() - lastClaim) < (24*3600*1000)) {
      claimDailyBtn.disabled = true;
      claimDailyBtn.textContent = 'Already claimed (wait 24h)';
    }

  } catch(err){
    console.error('loadDailyUI error', err);
    logDebug('‚ùå loadDailyUI error', (err && err.message) || err);
  }
}

/* ---------------- Initialization on auth ---------------- */
onAuthStateChanged(auth, async (user) => {
  if(!user){ window.location.href = '/login/index.html'; return; }
  const uid = user.uid;
  logDebug('onAuthStateChanged -> uid', uid);

  try{
    await ensureCoinsDoc(uid);
    await ensureQuestsExist();
    await loadAndRenderQuests(uid);
    await loadDailyUI(uid);

    // listen to coins for UI debug
    const coinsRef = doc(db,'user_coins', uid);
    onSnapshot(coinsRef, snap => {
      const v = Number(snap?.data()?.SphereCoins || 0);
      logDebug('coins snapshot:', v);
    });
  } catch(err){
    console.error('Init flow error', err);
    logDebug('‚ùå Init flow error', (err && err.message) || err);
  }
});

/* ---------------- Lightweight console to on-page debug mapping (optional) ---------------- */
</script>
</body>
</html>
